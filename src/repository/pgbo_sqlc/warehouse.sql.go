// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: warehouse.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteWarehouse = `-- name: DeleteWarehouse :exec
UPDATE warehouse
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    guid = $2
  AND deleted_at IS NULL
`

type DeleteWarehouseParams struct {
	DeletedBy sql.NullString `json:"deleted_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) DeleteWarehouse(ctx context.Context, arg DeleteWarehouseParams) error {
	_, err := q.db.ExecContext(ctx, deleteWarehouse, arg.DeletedBy, arg.Guid)
	return err
}

const findWithGUIDWarehouse = `-- name: FindWithGUIDWarehouse :many
SELECT id, guid, name, address, phone_number, is_active, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, last_login
FROM warehouse
WHERE guid = $1
`

func (q *Queries) FindWithGUIDWarehouse(ctx context.Context, guid string) ([]Warehouse, error) {
	rows, err := q.db.QueryContext(ctx, findWithGUIDWarehouse, guid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Warehouse
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Name,
			&i.Address,
			&i.PhoneNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWarehouse = `-- name: InsertWarehouse :one
INSERT INTO warehouse 
        (guid, name, address, phone_number, is_active, created_at, created_by)
    VALUES
        ($1, $2, $3, $4, $5, (now() at time zone 'UTC')::TIMESTAMP, $6)
RETURNING warehouse.id, warehouse.guid, warehouse.name, warehouse.address, warehouse.phone_number, warehouse.is_active, warehouse.created_at, warehouse.created_by, warehouse.updated_at, warehouse.updated_by, warehouse.deleted_at, warehouse.deleted_by, warehouse.last_login
`

type InsertWarehouseParams struct {
	Guid        string         `json:"guid"`
	Name        sql.NullString `json:"name"`
	Address     string         `json:"address"`
	PhoneNumber string         `json:"phone_number"`
	IsActive    sql.NullBool   `json:"is_active"`
	CreatedBy   string         `json:"created_by"`
}

func (q *Queries) InsertWarehouse(ctx context.Context, arg InsertWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, insertWarehouse,
		arg.Guid,
		arg.Name,
		arg.Address,
		arg.PhoneNumber,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.Address,
		&i.PhoneNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.LastLogin,
	)
	return i, err
}

const listWithFilterWarehouse = `-- name: ListWithFilterWarehouse :many
SELECT id, guid, name, address, phone_number, is_active, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, last_login
FROM warehouse
WHERE
    (CASE WHEN $1::bool THEN LOWER(name) LIKE LOWER($2) ELSE TRUE END)
    AND(CASE WHEN $3::bool THEN LOWER(address) LIKE LOWER($4) ELSE TRUE END)
    AND(CASE WHEN $5::bool THEN LOWER(phone_number) LIKE LOWER($6) ELSE TRUE END)
    AND deleted_at IS NULL
ORDER BY (CASE WHEN $7 = 'id ASC' THEN guid END) ASC,
         (CASE WHEN $7 = 'id DESC' THEN guid END) DESC,
         (CASE WHEN $7 = 'name ASC' THEN name END) ASC,
         (CASE WHEN $7 = 'name DESC' THEN name END) DESC,
         (CASE WHEN $7 = 'address ASC' THEN address END) ASC,
         (CASE WHEN $7 = 'address DESC' THEN address END) DESC,
         (CASE WHEN $7 = 'phone_number ASC' THEN phone_number END) ASC,
         (CASE WHEN $7 = 'phone_number DESC' THEN phone_number END) DESC,
         (CASE WHEN $7 = 'is_active ASC' THEN is_active END) ASC,
         (CASE WHEN $7 = 'is_active DESC' THEN is_active END) DESC,
         (CASE WHEN $7 = 'created_at ASC' THEN created_at END) ASC,
         (CASE WHEN $7 = 'created_at DESC' THEN created_at END) DESC,
         warehouse.created_at DESC
LIMIT $9
OFFSET $8
`

type ListWithFilterWarehouseParams struct {
	SetName        bool        `json:"set_name"`
	Name           string      `json:"name"`
	SetAddress     bool        `json:"set_address"`
	Address        string      `json:"address"`
	SetPhoneNumber bool        `json:"set_phone_number"`
	PhoneNumber    string      `json:"phone_number"`
	OrderParam     interface{} `json:"order_param"`
	OffsetPage     int32       `json:"offset_page"`
	LimitData      int32       `json:"limit_data"`
}

func (q *Queries) ListWithFilterWarehouse(ctx context.Context, arg ListWithFilterWarehouseParams) ([]Warehouse, error) {
	rows, err := q.db.QueryContext(ctx, listWithFilterWarehouse,
		arg.SetName,
		arg.Name,
		arg.SetAddress,
		arg.Address,
		arg.SetPhoneNumber,
		arg.PhoneNumber,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Warehouse
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Name,
			&i.Address,
			&i.PhoneNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWarehouse = `-- name: UpdateWarehouse :one
UPDATE warehouse 
SET name = $1, 
    address = $2, 
    phone_number = $3,
    is_active = $4, 
    updated_by = $5,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP 
WHERE guid = $6
RETURNING warehouse.id, warehouse.guid, warehouse.name, warehouse.address, warehouse.phone_number, warehouse.is_active, warehouse.created_at, warehouse.created_by, warehouse.updated_at, warehouse.updated_by, warehouse.deleted_at, warehouse.deleted_by, warehouse.last_login
`

type UpdateWarehouseParams struct {
	NewName      sql.NullString `json:"new_name"`
	Address      string         `json:"address"`
	PhoneNumber  string         `json:"phone_number"`
	IsActive     sql.NullBool   `json:"is_active"`
	NewCreatedBy sql.NullString `json:"new_created_by"`
	Guid         string         `json:"guid"`
}

func (q *Queries) UpdateWarehouse(ctx context.Context, arg UpdateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, updateWarehouse,
		arg.NewName,
		arg.Address,
		arg.PhoneNumber,
		arg.IsActive,
		arg.NewCreatedBy,
		arg.Guid,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.Address,
		&i.PhoneNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.LastLogin,
	)
	return i, err
}
