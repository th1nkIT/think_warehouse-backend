// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: auth_token.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const clearAuthTokenUserLogin = `-- name: ClearAuthTokenUserLogin :exec
UPDATE auth_token
SET
    is_login = false,
    user_login = null,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    name = $1
  AND device_id = $2
  AND device_type = $3
`

type ClearAuthTokenUserLoginParams struct {
	Name       string `json:"name"`
	DeviceID   string `json:"device_id"`
	DeviceType string `json:"device_type"`
}

func (q *Queries) ClearAuthTokenUserLogin(ctx context.Context, arg ClearAuthTokenUserLoginParams) error {
	_, err := q.db.ExecContext(ctx, clearAuthTokenUserLogin, arg.Name, arg.DeviceID, arg.DeviceType)
	return err
}

const getAuthToken = `-- name: GetAuthToken :one
SELECT t.id, t.name, t.device_id, t.device_type, t.token, t.token_expired, t.refresh_token, t.refresh_token_expired, t.is_login, t.user_login, t.created_at, t.updated_at
FROM auth_token t
WHERE
    t.name = $1
    AND t.device_id = $2
    AND t.device_type = $3
`

type GetAuthTokenParams struct {
	Name       string `json:"name"`
	DeviceID   string `json:"device_id"`
	DeviceType string `json:"device_type"`
}

func (q *Queries) GetAuthToken(ctx context.Context, arg GetAuthTokenParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getAuthToken, arg.Name, arg.DeviceID, arg.DeviceType)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DeviceID,
		&i.DeviceType,
		&i.Token,
		&i.TokenExpired,
		&i.RefreshToken,
		&i.RefreshTokenExpired,
		&i.IsLogin,
		&i.UserLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAuthToken = `-- name: InsertAuthToken :one
INSERT INTO auth_token
    (name, device_id, device_type, token, token_expired, refresh_token, refresh_token_expired, is_login, user_login, created_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, (now() at time zone 'UTC')::TIMESTAMP)
ON CONFLICT (name, device_id, device_type) DO
UPDATE
    SET token = $4,
    token_expired = $5,
    refresh_token = $6,
    refresh_token_expired = $7,
    is_login = $8,
    user_login = $9,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
RETURNING auth_token.id, auth_token.name, auth_token.device_id, auth_token.device_type, auth_token.token, auth_token.token_expired, auth_token.refresh_token, auth_token.refresh_token_expired, auth_token.is_login, auth_token.user_login, auth_token.created_at, auth_token.updated_at
`

type InsertAuthTokenParams struct {
	Name                string         `json:"name"`
	DeviceID            string         `json:"device_id"`
	DeviceType          string         `json:"device_type"`
	Token               string         `json:"token"`
	TokenExpired        time.Time      `json:"token_expired"`
	RefreshToken        string         `json:"refresh_token"`
	RefreshTokenExpired time.Time      `json:"refresh_token_expired"`
	IsLogin             bool           `json:"is_login"`
	UserLogin           sql.NullString `json:"user_login"`
}

func (q *Queries) InsertAuthToken(ctx context.Context, arg InsertAuthTokenParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, insertAuthToken,
		arg.Name,
		arg.DeviceID,
		arg.DeviceType,
		arg.Token,
		arg.TokenExpired,
		arg.RefreshToken,
		arg.RefreshTokenExpired,
		arg.IsLogin,
		arg.UserLogin,
	)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DeviceID,
		&i.DeviceType,
		&i.Token,
		&i.TokenExpired,
		&i.RefreshToken,
		&i.RefreshTokenExpired,
		&i.IsLogin,
		&i.UserLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const recordAuthTokenUserLogin = `-- name: RecordAuthTokenUserLogin :exec
UPDATE auth_token
SET
    is_login = true,
    user_login = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    name = $2
    AND device_id = $3
    AND device_type = $4
`

type RecordAuthTokenUserLoginParams struct {
	UserLogin  sql.NullString `json:"user_login"`
	Name       string         `json:"name"`
	DeviceID   string         `json:"device_id"`
	DeviceType string         `json:"device_type"`
}

func (q *Queries) RecordAuthTokenUserLogin(ctx context.Context, arg RecordAuthTokenUserLoginParams) error {
	_, err := q.db.ExecContext(ctx, recordAuthTokenUserLogin,
		arg.UserLogin,
		arg.Name,
		arg.DeviceID,
		arg.DeviceType,
	)
	return err
}
