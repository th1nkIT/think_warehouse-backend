// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: user_backoffice_role.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteUserBackofficeRole = `-- name: DeleteUserBackofficeRole :exec
UPDATE user_backoffice_role
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    id = $2
  AND deleted_at IS NULL
`

type DeleteUserBackofficeRoleParams struct {
	UpdatedBy sql.NullString `json:"updated_by"`
	ID        int64          `json:"id"`
}

func (q *Queries) DeleteUserBackofficeRole(ctx context.Context, arg DeleteUserBackofficeRoleParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserBackofficeRole, arg.UpdatedBy, arg.ID)
	return err
}

const getCountListUserBackofficeRole = `-- name: GetCountListUserBackofficeRole :one
SELECT count(ubr.id) FROM user_backoffice_role ubr
WHERE
    (CASE WHEN $1::bool THEN LOWER(ubr.name) LIKE LOWER($2) ELSE TRUE END)
    AND ubr.deleted_at IS NULL
`

type GetCountListUserBackofficeRoleParams struct {
	SetName bool   `json:"set_name"`
	Name    string `json:"name"`
}

func (q *Queries) GetCountListUserBackofficeRole(ctx context.Context, arg GetCountListUserBackofficeRoleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountListUserBackofficeRole, arg.SetName, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserBackofficeRole = `-- name: GetUserBackofficeRole :one
SELECT
       ubr.id, ubr.name, ubr.access, ubr.is_all_access, ubr.created_at, ubr.created_by, ubr.updated_at, ubr.updated_by, ubr.deleted_at, ubr.deleted_by
FROM
     user_backoffice_role ubr
WHERE ubr.id = $1
`

func (q *Queries) GetUserBackofficeRole(ctx context.Context, id int64) (UserBackofficeRole, error) {
	row := q.db.QueryRowContext(ctx, getUserBackofficeRole, id)
	var i UserBackofficeRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Access,
		&i.IsAllAccess,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const insertUserBackofficeRole = `-- name: InsertUserBackofficeRole :one
INSERT INTO user_backoffice_role
        (name, access, is_all_access, created_at, created_by)
    VALUES
        ($1, $2, $3, (now() at time zone 'UTC')::TIMESTAMP, $4)
RETURNING user_backoffice_role.id, user_backoffice_role.name, user_backoffice_role.access, user_backoffice_role.is_all_access, user_backoffice_role.created_at, user_backoffice_role.created_by, user_backoffice_role.updated_at, user_backoffice_role.updated_by, user_backoffice_role.deleted_at, user_backoffice_role.deleted_by
`

type InsertUserBackofficeRoleParams struct {
	Name        string         `json:"name"`
	Access      sql.NullString `json:"access"`
	IsAllAccess sql.NullBool   `json:"is_all_access"`
	CreatedBy   string         `json:"created_by"`
}

func (q *Queries) InsertUserBackofficeRole(ctx context.Context, arg InsertUserBackofficeRoleParams) (UserBackofficeRole, error) {
	row := q.db.QueryRowContext(ctx, insertUserBackofficeRole,
		arg.Name,
		arg.Access,
		arg.IsAllAccess,
		arg.CreatedBy,
	)
	var i UserBackofficeRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Access,
		&i.IsAllAccess,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listUserBackofficeRole = `-- name: ListUserBackofficeRole :many
SELECT ubr.id, ubr.name, ubr.access, ubr.is_all_access, ubr.created_at, ubr.created_by, ubr.updated_at, ubr.updated_by, ubr.deleted_at, ubr.deleted_by FROM user_backoffice_role ubr
WHERE
    (CASE WHEN $1::bool THEN LOWER(ubr.name) LIKE LOWER($2) ELSE TRUE END)
    AND ubr.deleted_at IS NULL
ORDER BY (CASE WHEN $3 = 'id ASC' THEN ubr.id END) ASC,
         (CASE WHEN $3 = 'id DESC' THEN ubr.id  END) DESC,
         (CASE WHEN $3 = 'name ASC' THEN ubr.name END) ASC,
         (CASE WHEN $3 = 'name DESC' THEN ubr.name  END) DESC,
         (CASE WHEN $3 = 'created_at ASC' THEN ubr.created_at END) ASC,
         (CASE WHEN $3 = 'created_at DESC' THEN ubr.created_at  END) DESC,
         ubr.created_at DESC
LIMIT $5
OFFSET $4
`

type ListUserBackofficeRoleParams struct {
	SetName    bool        `json:"set_name"`
	Name       string      `json:"name"`
	OrderParam interface{} `json:"order_param"`
	OffsetPage int32       `json:"offset_page"`
	LimitData  int32       `json:"limit_data"`
}

func (q *Queries) ListUserBackofficeRole(ctx context.Context, arg ListUserBackofficeRoleParams) ([]UserBackofficeRole, error) {
	rows, err := q.db.QueryContext(ctx, listUserBackofficeRole,
		arg.SetName,
		arg.Name,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserBackofficeRole
	for rows.Next() {
		var i UserBackofficeRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Access,
			&i.IsAllAccess,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserBackofficeRole = `-- name: UpdateUserBackofficeRole :one
UPDATE user_backoffice_role
SET
    name = $1,
    access = $2,
    is_all_access = $3,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $4
WHERE
    id = $5
    AND deleted_at IS NULL
RETURNING user_backoffice_role.id, user_backoffice_role.name, user_backoffice_role.access, user_backoffice_role.is_all_access, user_backoffice_role.created_at, user_backoffice_role.created_by, user_backoffice_role.updated_at, user_backoffice_role.updated_by, user_backoffice_role.deleted_at, user_backoffice_role.deleted_by
`

type UpdateUserBackofficeRoleParams struct {
	Name        string         `json:"name"`
	Access      sql.NullString `json:"access"`
	IsAllAccess sql.NullBool   `json:"is_all_access"`
	UpdatedBy   sql.NullString `json:"updated_by"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateUserBackofficeRole(ctx context.Context, arg UpdateUserBackofficeRoleParams) (UserBackofficeRole, error) {
	row := q.db.QueryRowContext(ctx, updateUserBackofficeRole,
		arg.Name,
		arg.Access,
		arg.IsAllAccess,
		arg.UpdatedBy,
		arg.ID,
	)
	var i UserBackofficeRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Access,
		&i.IsAllAccess,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
