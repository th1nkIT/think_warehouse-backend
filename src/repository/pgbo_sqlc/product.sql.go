// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE product
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    guid = $2
  AND deleted_at IS NULL
`

type DeleteProductParams struct {
	DeletedBy sql.NullString `json:"deleted_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, arg.DeletedBy, arg.Guid)
	return err
}

const getCountProductList = `-- name: GetCountProductList :one
SELECT COUNT(p.id) FROM product p
WHERE
    (CASE WHEN $1::bool THEN LOWER(p.name) LIKE LOWER($2) ELSE TRUE END)
    AND p.deleted_at IS NULL
`

type GetCountProductListParams struct {
	SetName bool   `json:"set_name"`
	Name    string `json:"name"`
}

func (q *Queries) GetCountProductList(ctx context.Context, arg GetCountProductListParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountProductList, arg.SetName, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProduct = `-- name: GetProduct :one
SELECT
    p.guid, p.name, p.product_picture_url, p.description, p.created_at, p.created_by,
    p.updated_at, p.updated_by, p.deleted_at, p.deleted_by,
    ub_created.name AS user_name, ub_created.guid AS user_id,
    ub_updated.name AS user_name_update, ub_updated.guid AS user_id_update
FROM
    product p
        LEFT JOIN user_backoffice ub_created ON ub_created.guid = p.created_by
        LEFT JOIN user_backoffice ub_updated ON ub_updated.guid = p.updated_by
WHERE
    p.guid = $1
  AND p.deleted_at IS NULL
`

type GetProductRow struct {
	Guid              string         `json:"guid"`
	Name              sql.NullString `json:"name"`
	ProductPictureUrl sql.NullString `json:"product_picture_url"`
	Description       string         `json:"description"`
	CreatedAt         time.Time      `json:"created_at"`
	CreatedBy         string         `json:"created_by"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	UpdatedBy         sql.NullString `json:"updated_by"`
	DeletedAt         sql.NullTime   `json:"deleted_at"`
	DeletedBy         sql.NullString `json:"deleted_by"`
	UserName          sql.NullString `json:"user_name"`
	UserID            sql.NullString `json:"user_id"`
	UserNameUpdate    sql.NullString `json:"user_name_update"`
	UserIDUpdate      sql.NullString `json:"user_id_update"`
}

func (q *Queries) GetProduct(ctx context.Context, guid string) (GetProductRow, error) {
	row := q.db.QueryRowContext(ctx, getProduct, guid)
	var i GetProductRow
	err := row.Scan(
		&i.Guid,
		&i.Name,
		&i.ProductPictureUrl,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.UserName,
		&i.UserID,
		&i.UserNameUpdate,
		&i.UserIDUpdate,
	)
	return i, err
}

const insertProduct = `-- name: InsertProduct :one
INSERT INTO product 
        (guid, name, product_picture_url, description, created_at, created_by)
    VALUES
        ($1, $2, $3, $4, (now() at time zone 'UTC')::TIMESTAMP, $5)
RETURNING product.id, product.guid, product.name, product.product_picture_url, product.description, product.created_at, product.created_by, product.updated_at, product.updated_by, product.deleted_at, product.deleted_by
`

type InsertProductParams struct {
	Guid              string         `json:"guid"`
	Name              sql.NullString `json:"name"`
	ProductPictureUrl sql.NullString `json:"product_picture_url"`
	Description       string         `json:"description"`
	CreatedBy         string         `json:"created_by"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, insertProduct,
		arg.Guid,
		arg.Name,
		arg.ProductPictureUrl,
		arg.Description,
		arg.CreatedBy,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProductPictureUrl,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listProduct = `-- name: ListProduct :many
SELECT
    p.guid, p.name, p.product_picture_url, p.description, p.created_at, p.created_by, p.updated_at, p.updated_by, p.deleted_at, p.deleted_by,
    ub_created.name AS user_name, ub_created.guid AS user_id,
    ub_updated.name AS user_name_update, ub_updated.guid AS user_id_update
FROM
    product p
        LEFT JOIN user_backoffice ub_created ON ub_created.guid = p.created_by
        LEFT JOIN user_backoffice ub_updated ON ub_updated.guid = p.updated_by
WHERE
    (CASE WHEN $1::bool THEN LOWER(p.name) LIKE LOWER($2) ELSE TRUE END)
  AND p.deleted_at IS NULL
ORDER BY
    (CASE WHEN $3 = 'id ASC' THEN p.guid END) ASC,
    (CASE WHEN $3 = 'id DESC' THEN p.guid END) DESC,
    (CASE WHEN $3 = 'name ASC' THEN p.name END) ASC,
    (CASE WHEN $3 = 'name DESC' THEN p.name END) DESC,
    (CASE WHEN $3 = 'created_at ASC' THEN p.created_at END) ASC,
    (CASE WHEN $3 = 'created_at DESC' THEN p.created_at END) DESC,
    p.created_at DESC
    LIMIT $5
OFFSET $4
`

type ListProductParams struct {
	SetName    bool        `json:"set_name"`
	Name       string      `json:"name"`
	OrderParam interface{} `json:"order_param"`
	OffsetPage int32       `json:"offset_page"`
	LimitData  int32       `json:"limit_data"`
}

type ListProductRow struct {
	Guid              string         `json:"guid"`
	Name              sql.NullString `json:"name"`
	ProductPictureUrl sql.NullString `json:"product_picture_url"`
	Description       string         `json:"description"`
	CreatedAt         time.Time      `json:"created_at"`
	CreatedBy         string         `json:"created_by"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	UpdatedBy         sql.NullString `json:"updated_by"`
	DeletedAt         sql.NullTime   `json:"deleted_at"`
	DeletedBy         sql.NullString `json:"deleted_by"`
	UserName          sql.NullString `json:"user_name"`
	UserID            sql.NullString `json:"user_id"`
	UserNameUpdate    sql.NullString `json:"user_name_update"`
	UserIDUpdate      sql.NullString `json:"user_id_update"`
}

func (q *Queries) ListProduct(ctx context.Context, arg ListProductParams) ([]ListProductRow, error) {
	rows, err := q.db.QueryContext(ctx, listProduct,
		arg.SetName,
		arg.Name,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductRow
	for rows.Next() {
		var i ListProductRow
		if err := rows.Scan(
			&i.Guid,
			&i.Name,
			&i.ProductPictureUrl,
			&i.Description,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.UserName,
			&i.UserID,
			&i.UserNameUpdate,
			&i.UserIDUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE product 
SET name = $1,
    product_picture_url = $2,
    description = $3,
    updated_by = $4,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP 
WHERE guid = $5
RETURNING product.id, product.guid, product.name, product.product_picture_url, product.description, product.created_at, product.created_by, product.updated_at, product.updated_by, product.deleted_at, product.deleted_by
`

type UpdateProductParams struct {
	Name              sql.NullString `json:"name"`
	ProductPictureUrl sql.NullString `json:"product_picture_url"`
	Description       string         `json:"description"`
	UpdatedBy         sql.NullString `json:"updated_by"`
	Guid              string         `json:"guid"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.Name,
		arg.ProductPictureUrl,
		arg.Description,
		arg.UpdatedBy,
		arg.Guid,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProductPictureUrl,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
