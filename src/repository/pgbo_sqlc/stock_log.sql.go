// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stock_log.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteStockLog = `-- name: DeleteStockLog :exec
UPDATE stock_log s
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    (CASE WHEN $2::bool THEN s.product_id = $3 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN s.product_variant_id = $5 ELSE TRUE END)
`

type DeleteStockLogParams struct {
	DeletedBy           sql.NullString `json:"deleted_by"`
	SetProductID        bool           `json:"set_product_id"`
	ProductID           sql.NullString `json:"product_id"`
	SetProductVariantID bool           `json:"set_product_variant_id"`
	ProductVariantID    sql.NullString `json:"product_variant_id"`
}

func (q *Queries) DeleteStockLog(ctx context.Context, arg DeleteStockLogParams) error {
	_, err := q.db.ExecContext(ctx, deleteStockLog,
		arg.DeletedBy,
		arg.SetProductID,
		arg.ProductID,
		arg.SetProductVariantID,
		arg.ProductVariantID,
	)
	return err
}

const getCountListStockLog = `-- name: GetCountListStockLog :one
SELECT
    count(s.id)
FROM
    stock_log s
        LEFT JOIN
    product p
    ON
        s.product_id = p.guid
        LEFT JOIN
    product_variant v
    ON
        s.product_variant_id = v.guid
WHERE
    (CASE WHEN $1::bool THEN s.stock_log >= $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN s.stock_log <= $2 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN LOWER(s.stock_type) LIKE LOWER ($5) ELSE TRUE END)
  AND (CASE WHEN $6::bool THEN LOWER(p.name) LIKE LOWER ($7) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN LOWER(v.name) LIKE LOWER ($9) ELSE TRUE END)
  AND s.deleted_at IS NULL
`

type GetCountListStockLogParams struct {
	SetStockLogGreater bool   `json:"set_stock_log_greater"`
	StockLog           int32  `json:"stock_log"`
	SetStockLogLower   bool   `json:"set_stock_log_lower"`
	SetIsStockType     bool   `json:"set_is_stock_type"`
	StockType          string `json:"stock_type"`
	SetProductName     bool   `json:"set_product_name"`
	ProductName        string `json:"product_name"`
	SetVariantName     bool   `json:"set_variant_name"`
	VariantName        string `json:"variant_name"`
}

func (q *Queries) GetCountListStockLog(ctx context.Context, arg GetCountListStockLogParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountListStockLog,
		arg.SetStockLogGreater,
		arg.StockLog,
		arg.SetStockLogLower,
		arg.SetIsStockType,
		arg.StockType,
		arg.SetProductName,
		arg.ProductName,
		arg.SetVariantName,
		arg.VariantName,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStockLogByProductAndVariantId = `-- name: GetStockLogByProductAndVariantId :many
SELECT
    s.id, s.guid, s.stock_id, s.product_id, s.product_variant_id, s.stock_log, s.stock_type, s.note, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by
FROM
    stock_log s
WHERE
    s.product_id = $1
  AND (CASE WHEN $2::bool THEN s.product_variant_id = $3 ELSE s.product_variant_id IS NULL END)
`

type GetStockLogByProductAndVariantIdParams struct {
	ProductID           sql.NullString `json:"product_id"`
	SetProductVariantID bool           `json:"set_product_variant_id"`
	ProductVariantID    sql.NullString `json:"product_variant_id"`
}

func (q *Queries) GetStockLogByProductAndVariantId(ctx context.Context, arg GetStockLogByProductAndVariantIdParams) ([]StockLog, error) {
	rows, err := q.db.QueryContext(ctx, getStockLogByProductAndVariantId, arg.ProductID, arg.SetProductVariantID, arg.ProductVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockLog
	for rows.Next() {
		var i StockLog
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.StockID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.StockLog,
			&i.StockType,
			&i.Note,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStockLog = `-- name: InsertStockLog :one
INSERT INTO stock_log
(guid, product_id, product_variant_id, stock_log, stock_type, note, created_at, created_by)
VALUES
    ($1, $2, $3, $4, $5, $6, (now() at time zone 'UTC')::TIMESTAMP, $7)
    RETURNING stock_log.id, stock_log.guid, stock_log.stock_id, stock_log.product_id, stock_log.product_variant_id, stock_log.stock_log, stock_log.stock_type, stock_log.note, stock_log.created_at, stock_log.created_by, stock_log.updated_at, stock_log.updated_by, stock_log.deleted_at, stock_log.deleted_by
`

type InsertStockLogParams struct {
	Guid             string            `json:"guid"`
	ProductID        sql.NullString    `json:"product_id"`
	ProductVariantID sql.NullString    `json:"product_variant_id"`
	StockLog         int32             `json:"stock_log"`
	StockType        NullStockTypeEnum `json:"stock_type"`
	Note             sql.NullString    `json:"note"`
	CreatedBy        string            `json:"created_by"`
}

func (q *Queries) InsertStockLog(ctx context.Context, arg InsertStockLogParams) (StockLog, error) {
	row := q.db.QueryRowContext(ctx, insertStockLog,
		arg.Guid,
		arg.ProductID,
		arg.ProductVariantID,
		arg.StockLog,
		arg.StockType,
		arg.Note,
		arg.CreatedBy,
	)
	var i StockLog
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.StockID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.StockLog,
		&i.StockType,
		&i.Note,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listStockLog = `-- name: ListStockLog :many
SELECT
    s.id, s.guid, s.stock_id, s.product_id, s.product_variant_id, s.stock_log, s.stock_type, s.note, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by,
    p.name AS product_name,
    v.name AS variant_name
FROM
    stock_log s
        LEFT JOIN
    product p
    ON
        s.product_id = p.guid
        LEFT JOIN
    product_variant v
    ON
        s.product_variant_id = v.guid
WHERE
    (CASE WHEN $1::bool THEN s.stock_log >= $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN s.stock_log <= $2 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN LOWER(s.stock_type) LIKE LOWER ($5) ELSE TRUE END)
  AND (CASE WHEN $6::bool THEN LOWER(p.name) LIKE LOWER ($7) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN LOWER(v.name) LIKE LOWER ($9) ELSE TRUE END)
  AND s.deleted_at IS NULL
ORDER BY (CASE WHEN $10 = 'id ASC' THEN s.guid END) ASC,
         (CASE WHEN $10 = 'id DESC' THEN s.guid END) DESC,
         (CASE WHEN $10 = 'stock_log ASC' THEN s.stock_log END) ASC,
         (CASE WHEN $10 = 'stock_log DESC' THEN s.stock_log END) DESC,
         (CASE WHEN $10 = 'stock_type ASC' THEN s.stock_type END) ASC,
         (CASE WHEN $10 = 'stock_type DESC' THEN s.stock_type END) DESC,
         (CASE WHEN $10 = 'product_name ASC' THEN p.name END) ASC,
         (CASE WHEN $10 = 'product_name DESC' THEN p.name END) DESC,
         (CASE WHEN $10 = 'variant_name ASC' THEN v.name END) ASC,
         (CASE WHEN $10 = 'variant_name DESC' THEN v.name END) DESC,
         (CASE WHEN $10 = 'created_at ASC' THEN s.created_at END) ASC,
         (CASE WHEN $10 = 'created_at DESC' THEN s.created_at END) DESC,
         s.created_at DESC
    LIMIT $12
OFFSET $11
`

type ListStockLogParams struct {
	SetStockLogGreater bool        `json:"set_stock_log_greater"`
	StockLog           int32       `json:"stock_log"`
	SetStockLogLower   bool        `json:"set_stock_log_lower"`
	SetIsStockType     bool        `json:"set_is_stock_type"`
	StockType          string      `json:"stock_type"`
	SetProductName     bool        `json:"set_product_name"`
	ProductName        string      `json:"product_name"`
	SetVariantName     bool        `json:"set_variant_name"`
	VariantName        string      `json:"variant_name"`
	OrderParam         interface{} `json:"order_param"`
	OffsetPage         int32       `json:"offset_page"`
	LimitData          int32       `json:"limit_data"`
}

type ListStockLogRow struct {
	ID               int64             `json:"id"`
	Guid             string            `json:"guid"`
	StockID          sql.NullString    `json:"stock_id"`
	ProductID        sql.NullString    `json:"product_id"`
	ProductVariantID sql.NullString    `json:"product_variant_id"`
	StockLog         int32             `json:"stock_log"`
	StockType        NullStockTypeEnum `json:"stock_type"`
	Note             sql.NullString    `json:"note"`
	CreatedAt        time.Time         `json:"created_at"`
	CreatedBy        string            `json:"created_by"`
	UpdatedAt        sql.NullTime      `json:"updated_at"`
	UpdatedBy        sql.NullString    `json:"updated_by"`
	DeletedAt        sql.NullTime      `json:"deleted_at"`
	DeletedBy        sql.NullString    `json:"deleted_by"`
	ProductName      sql.NullString    `json:"product_name"`
	VariantName      sql.NullString    `json:"variant_name"`
}

func (q *Queries) ListStockLog(ctx context.Context, arg ListStockLogParams) ([]ListStockLogRow, error) {
	rows, err := q.db.QueryContext(ctx, listStockLog,
		arg.SetStockLogGreater,
		arg.StockLog,
		arg.SetStockLogLower,
		arg.SetIsStockType,
		arg.StockType,
		arg.SetProductName,
		arg.ProductName,
		arg.SetVariantName,
		arg.VariantName,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockLogRow
	for rows.Next() {
		var i ListStockLogRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.StockID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.StockLog,
			&i.StockType,
			&i.Note,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.ProductName,
			&i.VariantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStockLog = `-- name: UpdateStockLog :one
UPDATE stock_log
SET
    stock_log = $1,
    stock_type = $2,
    note = $3,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $4
WHERE
    guid = $5
  AND deleted_at IS NULL
    RETURNING stock_log.id, stock_log.guid, stock_log.stock_id, stock_log.product_id, stock_log.product_variant_id, stock_log.stock_log, stock_log.stock_type, stock_log.note, stock_log.created_at, stock_log.created_by, stock_log.updated_at, stock_log.updated_by, stock_log.deleted_at, stock_log.deleted_by
`

type UpdateStockLogParams struct {
	StockLog  int32             `json:"stock_log"`
	StockType NullStockTypeEnum `json:"stock_type"`
	Note      sql.NullString    `json:"note"`
	UpdatedBy sql.NullString    `json:"updated_by"`
	Guid      string            `json:"guid"`
}

func (q *Queries) UpdateStockLog(ctx context.Context, arg UpdateStockLogParams) (StockLog, error) {
	row := q.db.QueryRowContext(ctx, updateStockLog,
		arg.StockLog,
		arg.StockType,
		arg.Note,
		arg.UpdatedBy,
		arg.Guid,
	)
	var i StockLog
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.StockID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.StockLog,
		&i.StockType,
		&i.Note,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
