// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product_variant.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteProductVariant = `-- name: DeleteProductVariant :exec
UPDATE product_variant
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    guid = $2
  AND deleted_at IS NULL
`

type DeleteProductVariantParams struct {
	DeletedBy sql.NullString `json:"deleted_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) DeleteProductVariant(ctx context.Context, arg DeleteProductVariantParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductVariant, arg.DeletedBy, arg.Guid)
	return err
}

const getCountListProductVariant = `-- name: GetCountListProductVariant :one
SELECT
    count(pv.id)
FROM
    product_variant pv
WHERE
    (CASE WHEN $1::bool THEN pv.product_id = $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN LOWER(pv.name) LIKE LOWER ($4) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN LOWER(pv.sku) LIKE LOWER ($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN pv.is_active = $8 ELSE TRUE END)
  AND pv.deleted_at IS NULL
`

type GetCountListProductVariantParams struct {
	SetProductID bool   `json:"set_product_id"`
	ProductID    string `json:"product_id"`
	SetName      bool   `json:"set_name"`
	Name         string `json:"name"`
	SetSku       bool   `json:"set_sku"`
	Sku          string `json:"sku"`
	SetIsActive  bool   `json:"set_is_active"`
	IsActive     bool   `json:"is_active"`
}

func (q *Queries) GetCountListProductVariant(ctx context.Context, arg GetCountListProductVariantParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountListProductVariant,
		arg.SetProductID,
		arg.ProductID,
		arg.SetName,
		arg.Name,
		arg.SetSku,
		arg.Sku,
		arg.SetIsActive,
		arg.IsActive,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProductVariant = `-- name: GetProductVariant :one
SELECT
    pv.id, pv.guid, pv.product_id, pv.name, pv.sku, pv.is_active, pv.is_active_by, pv.created_at, pv.created_by, pv.updated_at, pv.updated_by, pv.deleted_at, pv.deleted_by, pp.price, pp.discount, pp.discount_type
FROM
    product_variant pv
        LEFT JOIN
    product_price pp ON pv.guid = pp.product_variant_id
WHERE
    pv.guid = $1
  AND pv.product_id = $2
ORDER BY pv.created_at DESC
`

type GetProductVariantParams struct {
	Guid      string `json:"guid"`
	ProductID string `json:"product_id"`
}

type GetProductVariantRow struct {
	ID           int64                `json:"id"`
	Guid         string               `json:"guid"`
	ProductID    string               `json:"product_id"`
	Name         string               `json:"name"`
	Sku          string               `json:"sku"`
	IsActive     bool                 `json:"is_active"`
	IsActiveBy   sql.NullString       `json:"is_active_by"`
	CreatedAt    time.Time            `json:"created_at"`
	CreatedBy    string               `json:"created_by"`
	UpdatedAt    sql.NullTime         `json:"updated_at"`
	UpdatedBy    sql.NullString       `json:"updated_by"`
	DeletedAt    sql.NullTime         `json:"deleted_at"`
	DeletedBy    sql.NullString       `json:"deleted_by"`
	Price        sql.NullInt64        `json:"price"`
	Discount     sql.NullInt64        `json:"discount"`
	DiscountType NullDiscountTypeEnum `json:"discount_type"`
}

func (q *Queries) GetProductVariant(ctx context.Context, arg GetProductVariantParams) (GetProductVariantRow, error) {
	row := q.db.QueryRowContext(ctx, getProductVariant, arg.Guid, arg.ProductID)
	var i GetProductVariantRow
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.IsActive,
		&i.IsActiveBy,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.Price,
		&i.Discount,
		&i.DiscountType,
	)
	return i, err
}

const getProductVariantByNameAndProductID = `-- name: GetProductVariantByNameAndProductID :one
SELECT
    id, guid, product_id, name, sku, is_active, is_active_by, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
FROM
    product_variant
WHERE
    name = $1
  AND product_id = $2
  AND deleted_at IS NULL
`

type GetProductVariantByNameAndProductIDParams struct {
	Name      string `json:"name"`
	ProductID string `json:"product_id"`
}

func (q *Queries) GetProductVariantByNameAndProductID(ctx context.Context, arg GetProductVariantByNameAndProductIDParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getProductVariantByNameAndProductID, arg.Name, arg.ProductID)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.IsActive,
		&i.IsActiveBy,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const insertProductVariant = `-- name: InsertProductVariant :one
INSERT INTO product_variant
(guid, product_id, name, sku,
 is_active, created_at, created_by
)
VALUES
    ($1, $2, $3, $4,
     $5, (now() at time zone 'UTC')::TIMESTAMP, $6)
RETURNING product_variant.id, product_variant.guid, product_variant.product_id, product_variant.name, product_variant.sku, product_variant.is_active, product_variant.is_active_by, product_variant.created_at, product_variant.created_by, product_variant.updated_at, product_variant.updated_by, product_variant.deleted_at, product_variant.deleted_by
`

type InsertProductVariantParams struct {
	Guid      string `json:"guid"`
	ProductID string `json:"product_id"`
	Name      string `json:"name"`
	Sku       string `json:"sku"`
	IsActive  bool   `json:"is_active"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) InsertProductVariant(ctx context.Context, arg InsertProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, insertProductVariant,
		arg.Guid,
		arg.ProductID,
		arg.Name,
		arg.Sku,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.IsActive,
		&i.IsActiveBy,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listProductVariant = `-- name: ListProductVariant :many
SELECT
    pv.id, pv.guid, pv.product_id, pv.name, pv.sku, pv.is_active, pv.is_active_by, pv.created_at, pv.created_by, pv.updated_at, pv.updated_by, pv.deleted_at, pv.deleted_by
FROM
    product_variant pv
WHERE
    (CASE WHEN $1::bool THEN pv.product_id = $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN LOWER(pv.name) LIKE LOWER ($4) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN LOWER(pv.sku) LIKE LOWER ($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN pv.is_active = $8 ELSE TRUE END)
  AND pv.deleted_at IS NULL
ORDER BY (CASE WHEN $9 = 'id ASC' THEN pv.guid END) ASC,
         (CASE WHEN $9 = 'id DESC' THEN pv.guid END) DESC,
         (CASE WHEN $9 = 'product_id ASC' THEN pv.product_id END) ASC,
         (CASE WHEN $9 = 'product_id DESC' THEN pv.product_id END) DESC,
         (CASE WHEN $9 = 'name ASC' THEN pv.name END) ASC,
         (CASE WHEN $9 = 'name DESC' THEN pv.name END) DESC,
         (CASE WHEN $9 = 'sku ASC' THEN pv.sku END) ASC,
         (CASE WHEN $9 = 'sku DESC' THEN pv.sku END) DESC,
         (CASE WHEN $9 = 'is_active ASC' THEN pv.is_active END) ASC,
         (CASE WHEN $9 = 'is_active DESC' THEN pv.is_active END) DESC,
         (CASE WHEN $9 = 'created_at ASC' THEN pv.created_at END) ASC,
         (CASE WHEN $9 = 'created_at DESC' THEN pv.created_at END) DESC,
         pv.created_at DESC
`

type ListProductVariantParams struct {
	SetProductID bool        `json:"set_product_id"`
	ProductID    string      `json:"product_id"`
	SetName      bool        `json:"set_name"`
	Name         string      `json:"name"`
	SetSku       bool        `json:"set_sku"`
	Sku          string      `json:"sku"`
	SetIsActive  bool        `json:"set_is_active"`
	IsActive     bool        `json:"is_active"`
	OrderParam   interface{} `json:"order_param"`
}

func (q *Queries) ListProductVariant(ctx context.Context, arg ListProductVariantParams) ([]ProductVariant, error) {
	rows, err := q.db.QueryContext(ctx, listProductVariant,
		arg.SetProductID,
		arg.ProductID,
		arg.SetName,
		arg.Name,
		arg.SetSku,
		arg.Sku,
		arg.SetIsActive,
		arg.IsActive,
		arg.OrderParam,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.ProductID,
			&i.Name,
			&i.Sku,
			&i.IsActive,
			&i.IsActiveBy,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variant
SET
    product_id = $1,
    name = $2,
    sku = $3,
    is_active = $4,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $5
WHERE
    guid = $6
  AND deleted_at IS NULL
RETURNING product_variant.id, product_variant.guid, product_variant.product_id, product_variant.name, product_variant.sku, product_variant.is_active, product_variant.is_active_by, product_variant.created_at, product_variant.created_by, product_variant.updated_at, product_variant.updated_by, product_variant.deleted_at, product_variant.deleted_by
`

type UpdateProductVariantParams struct {
	ProductID string         `json:"product_id"`
	Name      string         `json:"name"`
	Sku       string         `json:"sku"`
	IsActive  bool           `json:"is_active"`
	UpdatedBy sql.NullString `json:"updated_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, updateProductVariant,
		arg.ProductID,
		arg.Name,
		arg.Sku,
		arg.IsActive,
		arg.UpdatedBy,
		arg.Guid,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.IsActive,
		&i.IsActiveBy,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const updateProductVariantIsActive = `-- name: UpdateProductVariantIsActive :exec
UPDATE product_variant
SET
    is_active = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $2
WHERE
    guid = $3
  AND deleted_at IS NULL
`

type UpdateProductVariantIsActiveParams struct {
	IsActive  bool           `json:"is_active"`
	UpdatedBy sql.NullString `json:"updated_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) UpdateProductVariantIsActive(ctx context.Context, arg UpdateProductVariantIsActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateProductVariantIsActive, arg.IsActive, arg.UpdatedBy, arg.Guid)
	return err
}
