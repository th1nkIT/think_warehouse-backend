// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: user_handheld.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteUserHandheld = `-- name: DeleteUserHandheld :exec
UPDATE user_handheld
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $1
    AND deleted_at IS NULL
`

func (q *Queries) DeleteUserHandheld(ctx context.Context, guid string) error {
	_, err := q.db.ExecContext(ctx, deleteUserHandheld, guid)
	return err
}

const getCountUserHandheld = `-- name: GetCountUserHandheld :one
SELECT
    count(uh.id)
FROM
    user_handheld uh
WHERE
    (CASE WHEN $1::bool THEN LOWER(uh.name) LIKE LOWER($2) ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN LOWER(uh.phone) LIKE LOWER($4) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN LOWER(uh.email) LIKE LOWER($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN LOWER(uh.gender) LIKE LOWER($8) ELSE TRUE END)
  AND (CASE WHEN $9::bool THEN LOWER(uh.address) LIKE LOWER($10) ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN uh.is_active = $12 ELSE TRUE END)
  AND uh.deleted_at IS NULL
`

type GetCountUserHandheldParams struct {
	SetName     bool         `json:"set_name"`
	Name        string       `json:"name"`
	SetPhone    bool         `json:"set_phone"`
	Phone       string       `json:"phone"`
	SetEmail    bool         `json:"set_email"`
	Email       string       `json:"email"`
	SetGender   bool         `json:"set_gender"`
	Gender      string       `json:"gender"`
	SetAddress  bool         `json:"set_address"`
	Address     string       `json:"address"`
	SetIsActive bool         `json:"set_is_active"`
	IsActive    sql.NullBool `json:"is_active"`
}

func (q *Queries) GetCountUserHandheld(ctx context.Context, arg GetCountUserHandheldParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountUserHandheld,
		arg.SetName,
		arg.Name,
		arg.SetPhone,
		arg.Phone,
		arg.SetEmail,
		arg.Email,
		arg.SetGender,
		arg.Gender,
		arg.SetAddress,
		arg.Address,
		arg.SetIsActive,
		arg.IsActive,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserHandheld = `-- name: GetUserHandheld :one
SELECT
    uh.id, uh.guid, uh.name, uh.profile_picture_image_url, uh.phone, uh.email, uh.gender, uh.address, uh.salt, uh.password, uh.is_active, uh.fcm_token, uh.created_at, uh.updated_at, uh.deleted_at, uh.last_login
FROM user_handheld uh
WHERE
    uh.guid = $1
`

func (q *Queries) GetUserHandheld(ctx context.Context, guid string) (UserHandheld, error) {
	row := q.db.QueryRowContext(ctx, getUserHandheld, guid)
	var i UserHandheld
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProfilePictureImageUrl,
		&i.Phone,
		&i.Email,
		&i.Gender,
		&i.Address,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserHandheldByEmail = `-- name: GetUserHandheldByEmail :one
SELECT
    uh.id, uh.guid, uh.name, uh.profile_picture_image_url, uh.phone, uh.email, uh.gender, uh.address, uh.salt, uh.password, uh.is_active, uh.fcm_token, uh.created_at, uh.updated_at, uh.deleted_at, uh.last_login
FROM user_handheld uh
WHERE
        uh.email = $1
`

func (q *Queries) GetUserHandheldByEmail(ctx context.Context, email string) (UserHandheld, error) {
	row := q.db.QueryRowContext(ctx, getUserHandheldByEmail, email)
	var i UserHandheld
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProfilePictureImageUrl,
		&i.Phone,
		&i.Email,
		&i.Gender,
		&i.Address,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLogin,
	)
	return i, err
}

const insertUserHandheld = `-- name: InsertUserHandheld :one
INSERT INTO user_handheld
    (guid, name, profile_picture_image_url, phone, email, gender, address, salt, password, is_active, fcm_token, created_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, true, $10, (now() at time zone 'UTC')::TIMESTAMP)
RETURNING user_handheld.id, user_handheld.guid, user_handheld.name, user_handheld.profile_picture_image_url, user_handheld.phone, user_handheld.email, user_handheld.gender, user_handheld.address, user_handheld.salt, user_handheld.password, user_handheld.is_active, user_handheld.fcm_token, user_handheld.created_at, user_handheld.updated_at, user_handheld.deleted_at, user_handheld.last_login
`

type InsertUserHandheldParams struct {
	Guid                   string         `json:"guid"`
	Name                   string         `json:"name"`
	ProfilePictureImageUrl sql.NullString `json:"profile_picture_image_url"`
	Phone                  sql.NullString `json:"phone"`
	Email                  string         `json:"email"`
	Gender                 string         `json:"gender"`
	Address                sql.NullString `json:"address"`
	Salt                   string         `json:"salt"`
	Password               string         `json:"password"`
	FcmToken               sql.NullString `json:"fcm_token"`
}

func (q *Queries) InsertUserHandheld(ctx context.Context, arg InsertUserHandheldParams) (UserHandheld, error) {
	row := q.db.QueryRowContext(ctx, insertUserHandheld,
		arg.Guid,
		arg.Name,
		arg.ProfilePictureImageUrl,
		arg.Phone,
		arg.Email,
		arg.Gender,
		arg.Address,
		arg.Salt,
		arg.Password,
		arg.FcmToken,
	)
	var i UserHandheld
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProfilePictureImageUrl,
		&i.Phone,
		&i.Email,
		&i.Gender,
		&i.Address,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLogin,
	)
	return i, err
}

const listUserHandheld = `-- name: ListUserHandheld :many
SELECT
    uh.id, uh.guid, uh.name, uh.profile_picture_image_url, uh.phone, uh.email, uh.gender, uh.address, uh.salt, uh.password, uh.is_active, uh.fcm_token, uh.created_at, uh.updated_at, uh.deleted_at, uh.last_login
FROM
    user_handheld uh
WHERE
    (CASE WHEN $1::bool THEN LOWER(uh.name) LIKE LOWER($2) ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN LOWER(uh.phone) LIKE LOWER($4) ELSE TRUE END)
    AND (CASE WHEN $5::bool THEN LOWER(uh.email) LIKE LOWER($6) ELSE TRUE END)
    AND (CASE WHEN $7::bool THEN LOWER(uh.gender) LIKE LOWER($8) ELSE TRUE END)
    AND (CASE WHEN $9::bool THEN LOWER(uh.address) LIKE LOWER($10) ELSE TRUE END)
    AND (CASE WHEN $11::bool THEN uh.is_active = $12 ELSE TRUE END)
    AND uh.deleted_at IS NULL
ORDER BY (CASE WHEN $13 = 'id ASC' THEN uh.guid END) ASC,
         (CASE WHEN $13 = 'id DESC' THEN uh.guid  END) DESC,
         (CASE WHEN $13 = 'name ASC' THEN uh.name END) ASC,
         (CASE WHEN $13 = 'name DESC' THEN uh.name  END) DESC,
         (CASE WHEN $13 = 'phone ASC' THEN uh.phone END) ASC,
         (CASE WHEN $13 = 'phone DESC' THEN uh.phone  END) DESC,
         (CASE WHEN $13 = 'email ASC' THEN uh.email END) ASC,
         (CASE WHEN $13 = 'email DESC' THEN uh.email  END) DESC,
         (CASE WHEN $13 = 'gender ASC' THEN uh.gender END) ASC,
         (CASE WHEN $13 = 'gender DESC' THEN uh.gender  END) DESC,
         (CASE WHEN $13 = 'address ASC' THEN uh.address END) ASC,
         (CASE WHEN $13 = 'address DESC' THEN uh.address  END) DESC,
         (CASE WHEN $13 = 'is_active ASC' THEN uh.is_active END) ASC,
         (CASE WHEN $13 = 'is_active DESC' THEN uh.is_active  END) DESC,
         (CASE WHEN $13 = 'created_at ASC' THEN uh.created_at END) ASC,
         (CASE WHEN $13 = 'created_at DESC' THEN uh.created_at  END) DESC,
         uh.created_at DESC
LIMIT $15
OFFSET $14
`

type ListUserHandheldParams struct {
	SetName     bool         `json:"set_name"`
	Name        string       `json:"name"`
	SetPhone    bool         `json:"set_phone"`
	Phone       string       `json:"phone"`
	SetEmail    bool         `json:"set_email"`
	Email       string       `json:"email"`
	SetGender   bool         `json:"set_gender"`
	Gender      string       `json:"gender"`
	SetAddress  bool         `json:"set_address"`
	Address     string       `json:"address"`
	SetIsActive bool         `json:"set_is_active"`
	IsActive    sql.NullBool `json:"is_active"`
	OrderParam  interface{}  `json:"order_param"`
	OffsetPage  int32        `json:"offset_page"`
	LimitData   int32        `json:"limit_data"`
}

func (q *Queries) ListUserHandheld(ctx context.Context, arg ListUserHandheldParams) ([]UserHandheld, error) {
	rows, err := q.db.QueryContext(ctx, listUserHandheld,
		arg.SetName,
		arg.Name,
		arg.SetPhone,
		arg.Phone,
		arg.SetEmail,
		arg.Email,
		arg.SetGender,
		arg.Gender,
		arg.SetAddress,
		arg.Address,
		arg.SetIsActive,
		arg.IsActive,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserHandheld
	for rows.Next() {
		var i UserHandheld
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Name,
			&i.ProfilePictureImageUrl,
			&i.Phone,
			&i.Email,
			&i.Gender,
			&i.Address,
			&i.Salt,
			&i.Password,
			&i.IsActive,
			&i.FcmToken,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordUserHandheldLastLogin = `-- name: RecordUserHandheldLastLogin :exec
UPDATE user_handheld
SET
    last_login = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $1
    AND deleted_at IS NULL
`

func (q *Queries) RecordUserHandheldLastLogin(ctx context.Context, guid string) error {
	_, err := q.db.ExecContext(ctx, recordUserHandheldLastLogin, guid)
	return err
}

const updateUserHandheld = `-- name: UpdateUserHandheld :one
UPDATE user_handheld
SET
    name = $1,
    profile_picture_image_url = $2,
    phone = $3,
    gender = $4,
    address = $5,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $6
    AND deleted_at IS NULL
RETURNING user_handheld.id, user_handheld.guid, user_handheld.name, user_handheld.profile_picture_image_url, user_handheld.phone, user_handheld.email, user_handheld.gender, user_handheld.address, user_handheld.salt, user_handheld.password, user_handheld.is_active, user_handheld.fcm_token, user_handheld.created_at, user_handheld.updated_at, user_handheld.deleted_at, user_handheld.last_login
`

type UpdateUserHandheldParams struct {
	Name                   string         `json:"name"`
	ProfilePictureImageUrl sql.NullString `json:"profile_picture_image_url"`
	Phone                  sql.NullString `json:"phone"`
	Gender                 string         `json:"gender"`
	Address                sql.NullString `json:"address"`
	Guid                   string         `json:"guid"`
}

func (q *Queries) UpdateUserHandheld(ctx context.Context, arg UpdateUserHandheldParams) (UserHandheld, error) {
	row := q.db.QueryRowContext(ctx, updateUserHandheld,
		arg.Name,
		arg.ProfilePictureImageUrl,
		arg.Phone,
		arg.Gender,
		arg.Address,
		arg.Guid,
	)
	var i UserHandheld
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProfilePictureImageUrl,
		&i.Phone,
		&i.Email,
		&i.Gender,
		&i.Address,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLogin,
	)
	return i, err
}

const updateUserHandheldFcmToken = `-- name: UpdateUserHandheldFcmToken :one
UPDATE user_handheld
SET
    fcm_token = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $2
    AND deleted_at IS NULL
RETURNING user_handheld.id, user_handheld.guid, user_handheld.name, user_handheld.profile_picture_image_url, user_handheld.phone, user_handheld.email, user_handheld.gender, user_handheld.address, user_handheld.salt, user_handheld.password, user_handheld.is_active, user_handheld.fcm_token, user_handheld.created_at, user_handheld.updated_at, user_handheld.deleted_at, user_handheld.last_login
`

type UpdateUserHandheldFcmTokenParams struct {
	FcmToken sql.NullString `json:"fcm_token"`
	Guid     string         `json:"guid"`
}

func (q *Queries) UpdateUserHandheldFcmToken(ctx context.Context, arg UpdateUserHandheldFcmTokenParams) (UserHandheld, error) {
	row := q.db.QueryRowContext(ctx, updateUserHandheldFcmToken, arg.FcmToken, arg.Guid)
	var i UserHandheld
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.Name,
		&i.ProfilePictureImageUrl,
		&i.Phone,
		&i.Email,
		&i.Gender,
		&i.Address,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.FcmToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastLogin,
	)
	return i, err
}

const updateUserHandheldIsActive = `-- name: UpdateUserHandheldIsActive :exec
UPDATE user_handheld
SET
    is_active = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $2
    AND deleted_at IS NULL
`

type UpdateUserHandheldIsActiveParams struct {
	IsActive sql.NullBool `json:"is_active"`
	Guid     string       `json:"guid"`
}

func (q *Queries) UpdateUserHandheldIsActive(ctx context.Context, arg UpdateUserHandheldIsActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateUserHandheldIsActive, arg.IsActive, arg.Guid)
	return err
}

const updateUserHandheldPassword = `-- name: UpdateUserHandheldPassword :exec
UPDATE user_handheld
SET
    salt = $1,
    password = $2,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE
    guid = $3
    AND deleted_at IS NULL
RETURNING user_handheld.id, user_handheld.guid, user_handheld.name, user_handheld.profile_picture_image_url, user_handheld.phone, user_handheld.email, user_handheld.gender, user_handheld.address, user_handheld.salt, user_handheld.password, user_handheld.is_active, user_handheld.fcm_token, user_handheld.created_at, user_handheld.updated_at, user_handheld.deleted_at, user_handheld.last_login
`

type UpdateUserHandheldPasswordParams struct {
	Salt     string `json:"salt"`
	Password string `json:"password"`
	Guid     string `json:"guid"`
}

func (q *Queries) UpdateUserHandheldPassword(ctx context.Context, arg UpdateUserHandheldPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserHandheldPassword, arg.Salt, arg.Password, arg.Guid)
	return err
}
