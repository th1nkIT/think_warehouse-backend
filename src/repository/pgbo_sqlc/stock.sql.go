// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stock.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteStock = `-- name: DeleteStock :exec
UPDATE stock s
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE
    (CASE WHEN $2::bool THEN s.product_id = $3 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN s.product_variant_id = $5 ELSE TRUE END)
`

type DeleteStockParams struct {
	DeletedBy           sql.NullString `json:"deleted_by"`
	SetProductID        bool           `json:"set_product_id"`
	ProductID           sql.NullString `json:"product_id"`
	SetProductVariantID bool           `json:"set_product_variant_id"`
	ProductVariantID    sql.NullString `json:"product_variant_id"`
}

func (q *Queries) DeleteStock(ctx context.Context, arg DeleteStockParams) error {
	_, err := q.db.ExecContext(ctx, deleteStock,
		arg.DeletedBy,
		arg.SetProductID,
		arg.ProductID,
		arg.SetProductVariantID,
		arg.ProductVariantID,
	)
	return err
}

const getCountListStock = `-- name: GetCountListStock :one
SELECT
    count(s.id)
FROM
    stock s
        JOIN
    product p
    ON
        s.product_id = p.guid
        LEFT JOIN
    product_variant v
    ON
        s.product_variant_id = v.guid
WHERE
    (CASE WHEN $1::bool THEN s.stock >= $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN s.stock <= $2 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN LOWER(p.name) LIKE LOWER ($5) ELSE TRUE END)
  AND (CASE WHEN $6::bool THEN LOWER(v.name) LIKE LOWER ($7) ELSE TRUE END)
  AND s.deleted_at IS NULL
`

type GetCountListStockParams struct {
	SetStockGreater bool   `json:"set_stock_greater"`
	Stock           int64  `json:"stock"`
	SetStockLower   bool   `json:"set_stock_lower"`
	SetProductName  bool   `json:"set_product_name"`
	ProductName     string `json:"product_name"`
	SetVariantName  bool   `json:"set_variant_name"`
	VariantName     string `json:"variant_name"`
}

func (q *Queries) GetCountListStock(ctx context.Context, arg GetCountListStockParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountListStock,
		arg.SetStockGreater,
		arg.Stock,
		arg.SetStockLower,
		arg.SetProductName,
		arg.ProductName,
		arg.SetVariantName,
		arg.VariantName,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStock = `-- name: GetStock :one
SELECT
    s.id, s.guid, s.product_id, s.product_variant_id, s.stock, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by,
    p.name AS product_name,
    p.product_sku AS product_sku,
    v.name AS variant_name,
    v.sku AS variant_sku
FROM
    stock s
        LEFT JOIN
    product p
    ON
        s.product_id = p.guid
        LEFT JOIN
    product_variant v
    ON
        s.product_variant_id = v.guid
WHERE
    s.guid = $1
`

type GetStockRow struct {
	ID               int64          `json:"id"`
	Guid             string         `json:"guid"`
	ProductID        sql.NullString `json:"product_id"`
	ProductVariantID sql.NullString `json:"product_variant_id"`
	Stock            int64          `json:"stock"`
	CreatedAt        time.Time      `json:"created_at"`
	CreatedBy        string         `json:"created_by"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	UpdatedBy        sql.NullString `json:"updated_by"`
	DeletedAt        sql.NullTime   `json:"deleted_at"`
	DeletedBy        sql.NullString `json:"deleted_by"`
	ProductName      sql.NullString `json:"product_name"`
	ProductSku       sql.NullString `json:"product_sku"`
	VariantName      sql.NullString `json:"variant_name"`
	VariantSku       sql.NullString `json:"variant_sku"`
}

func (q *Queries) GetStock(ctx context.Context, guid string) (GetStockRow, error) {
	row := q.db.QueryRowContext(ctx, getStock, guid)
	var i GetStockRow
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Stock,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.ProductName,
		&i.ProductSku,
		&i.VariantName,
		&i.VariantSku,
	)
	return i, err
}

const getStockByProduct = `-- name: GetStockByProduct :many
SELECT
    s.id, s.guid, s.product_id, s.product_variant_id, s.stock, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by
FROM
    stock s
WHERE
    s.product_id = $1
`

func (q *Queries) GetStockByProduct(ctx context.Context, productID sql.NullString) ([]Stock, error) {
	rows, err := q.db.QueryContext(ctx, getStockByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stock
	for rows.Next() {
		var i Stock
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.ProductID,
			&i.ProductVariantID,
			&i.Stock,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockByProductAndVariant = `-- name: GetStockByProductAndVariant :one
SELECT
    s.id, s.guid, s.product_id, s.product_variant_id, s.stock, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by
FROM
    stock s
WHERE
    s.product_id = $1
  AND (CASE WHEN $2::bool THEN s.product_variant_id = $3 ELSE s.product_variant_id IS NULL END)
`

type GetStockByProductAndVariantParams struct {
	ProductID           sql.NullString `json:"product_id"`
	SetProductVariantID bool           `json:"set_product_variant_id"`
	ProductVariantID    sql.NullString `json:"product_variant_id"`
}

func (q *Queries) GetStockByProductAndVariant(ctx context.Context, arg GetStockByProductAndVariantParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockByProductAndVariant, arg.ProductID, arg.SetProductVariantID, arg.ProductVariantID)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Stock,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getStockByProductOrVariantId = `-- name: GetStockByProductOrVariantId :one
SELECT
    s.id, s.guid, s.product_id, s.product_variant_id, s.stock, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by
FROM
    stock s
WHERE
    (CASE WHEN $1::bool THEN s.product_id = $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN s.product_variant_id = $4 ELSE TRUE END)
`

type GetStockByProductOrVariantIdParams struct {
	SetProductID        bool           `json:"set_product_id"`
	ProductID           sql.NullString `json:"product_id"`
	SetProductVariantID bool           `json:"set_product_variant_id"`
	ProductVariantID    sql.NullString `json:"product_variant_id"`
}

func (q *Queries) GetStockByProductOrVariantId(ctx context.Context, arg GetStockByProductOrVariantIdParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, getStockByProductOrVariantId,
		arg.SetProductID,
		arg.ProductID,
		arg.SetProductVariantID,
		arg.ProductVariantID,
	)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Stock,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const insertStock = `-- name: InsertStock :one
INSERT INTO stock
(guid, product_id, product_variant_id, stock, created_at, created_by)
VALUES
    ($1, $2, $3, $4, (now() at time zone 'UTC')::TIMESTAMP, $5)
    RETURNING stock.id, stock.guid, stock.product_id, stock.product_variant_id, stock.stock, stock.created_at, stock.created_by, stock.updated_at, stock.updated_by, stock.deleted_at, stock.deleted_by
`

type InsertStockParams struct {
	Guid             string         `json:"guid"`
	ProductID        sql.NullString `json:"product_id"`
	ProductVariantID sql.NullString `json:"product_variant_id"`
	Stock            int64          `json:"stock"`
	CreatedBy        string         `json:"created_by"`
}

func (q *Queries) InsertStock(ctx context.Context, arg InsertStockParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, insertStock,
		arg.Guid,
		arg.ProductID,
		arg.ProductVariantID,
		arg.Stock,
		arg.CreatedBy,
	)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Stock,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listStock = `-- name: ListStock :many
SELECT
    s.id, s.guid, s.product_id, s.product_variant_id, s.stock, s.created_at, s.created_by, s.updated_at, s.updated_by, s.deleted_at, s.deleted_by,
    p.name AS product_name,
    p.product_sku AS product_sku,
    v.name AS variant_name,
    v.sku AS variant_sku
FROM
    stock s
        JOIN
    product p
    ON
        s.product_id = p.guid
        LEFT JOIN
    product_variant v
    ON
        s.product_variant_id = v.guid
WHERE
    (CASE WHEN $1::bool THEN s.stock >= $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN s.stock <= $2 ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN LOWER(p.name) LIKE LOWER ($5) ELSE TRUE END)
  AND (CASE WHEN $6::bool THEN LOWER(v.name) LIKE LOWER ($7) ELSE TRUE END)
  AND s.deleted_at IS NULL
ORDER BY (CASE WHEN $8 = 'id ASC' THEN s.guid END) ASC,
         (CASE WHEN $8 = 'id DESC' THEN s.guid END) DESC,
         (CASE WHEN $8 = 'stock ASC' THEN s.stock END) ASC,
         (CASE WHEN $8 = 'stock DESC' THEN s.stock END) DESC,
         (CASE WHEN $8 = 'product_name ASC' THEN p.name END) ASC,
         (CASE WHEN $8 = 'product_name DESC' THEN p.name END) DESC,
         (CASE WHEN $8 = 'variant_name ASC' THEN v.name END) ASC,
         (CASE WHEN $8 = 'variant_name DESC' THEN v.name END) DESC,
         (CASE WHEN $8 = 'created_at ASC' THEN s.created_at END) ASC,
         (CASE WHEN $8 = 'created_at DESC' THEN s.created_at END) DESC,
         s.created_at DESC
    LIMIT $10
OFFSET $9
`

type ListStockParams struct {
	SetStockGreater bool        `json:"set_stock_greater"`
	Stock           int64       `json:"stock"`
	SetStockLower   bool        `json:"set_stock_lower"`
	SetProductName  bool        `json:"set_product_name"`
	ProductName     string      `json:"product_name"`
	SetVariantName  bool        `json:"set_variant_name"`
	VariantName     string      `json:"variant_name"`
	OrderParam      interface{} `json:"order_param"`
	OffsetPage      int32       `json:"offset_page"`
	LimitData       int32       `json:"limit_data"`
}

type ListStockRow struct {
	ID               int64          `json:"id"`
	Guid             string         `json:"guid"`
	ProductID        sql.NullString `json:"product_id"`
	ProductVariantID sql.NullString `json:"product_variant_id"`
	Stock            int64          `json:"stock"`
	CreatedAt        time.Time      `json:"created_at"`
	CreatedBy        string         `json:"created_by"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	UpdatedBy        sql.NullString `json:"updated_by"`
	DeletedAt        sql.NullTime   `json:"deleted_at"`
	DeletedBy        sql.NullString `json:"deleted_by"`
	ProductName      sql.NullString `json:"product_name"`
	ProductSku       string         `json:"product_sku"`
	VariantName      sql.NullString `json:"variant_name"`
	VariantSku       sql.NullString `json:"variant_sku"`
}

func (q *Queries) ListStock(ctx context.Context, arg ListStockParams) ([]ListStockRow, error) {
	rows, err := q.db.QueryContext(ctx, listStock,
		arg.SetStockGreater,
		arg.Stock,
		arg.SetStockLower,
		arg.SetProductName,
		arg.ProductName,
		arg.SetVariantName,
		arg.VariantName,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockRow
	for rows.Next() {
		var i ListStockRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.ProductID,
			&i.ProductVariantID,
			&i.Stock,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.ProductName,
			&i.ProductSku,
			&i.VariantName,
			&i.VariantSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStock = `-- name: UpdateStock :one
UPDATE stock
SET
    stock = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $2
WHERE
    guid = $3
  AND deleted_at IS NULL
    RETURNING stock.id, stock.guid, stock.product_id, stock.product_variant_id, stock.stock, stock.created_at, stock.created_by, stock.updated_at, stock.updated_by, stock.deleted_at, stock.deleted_by
`

type UpdateStockParams struct {
	Stock     int64          `json:"stock"`
	UpdatedBy sql.NullString `json:"updated_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) UpdateStock(ctx context.Context, arg UpdateStockParams) (Stock, error) {
	row := q.db.QueryRowContext(ctx, updateStock, arg.Stock, arg.UpdatedBy, arg.Guid)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Guid,
		&i.ProductID,
		&i.ProductVariantID,
		&i.Stock,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
